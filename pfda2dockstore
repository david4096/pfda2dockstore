#!/usr/bin/env python3

import argparse
import subprocess
import requests
import json
import sys
import yaml
from github import Github
from agithub.GitHub import GitHub

def main():
    parser = argparse.ArgumentParser(description='Export precisionFDA app to Dockstore', formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    parser.add_argument('-p','--pfda-token', metavar='XXX', type=str, help='precisionFDA auth token')
    parser.add_argument('-v', '--verbose', action='store_true', help='verbose log to standard error')
    parser.add_argument('--github-token', dest='gh_token', help='your github token')
    parser.add_argument('--github-org', dest='gh_org', help='the github organization to make repositories in')
    # TODO: quay is not being used
    parser.add_argument('--dockerhub-org', dest='d_org', help='the Quay.io organization to make repositories in')
    #parser.add_argument('--quay-token', dest='q_token', help='your Quay.io token')
    #parser.add_argument('--quay-account', dest='q_account', help='the Quay.io account (eg. robot account) to make repositories in')
    parser.add_argument('--dockstore-org', dest='ds_org', help='The Dockstore organization to make repositories in')
    parser.add_argument('--dockstore-token', dest='ds_token', help='Your Dockstore token')

    # FIXME: currently it just takes the most recent version
    #parser.add_argument('--app-version', dest='app_version', type=str, help="precisionFDA app version")
    parser.add_argument('--app-name', dest='app_name', type=str, help="precisionFDA app name")
    args = parser.parse_args()

    # get app info
    apps = resolve_pfda_app_name(args.pfda_token, args.app_name)
    apps = sorted(apps, key=lambda app: app["revision"], reverse=True)
    if len(apps) == 0:
        print("Couldn't find app named " + args.app_name, file=sys.stderr)
        sys.exit(1)
    elif len(apps) > 1:
        print("Note: multiple public apps named {}; using highest revision {}".format(args.app_name, apps[0]["revision"]), file=sys.stderr)


    # the app
    app = apps[0]
    # the app revision
    app_version = app["revision"]
    # the docker path on quay
    # docker_tag = "quay.io/" + args.q_org + "/" + args.app_name + ":" + str(app_version)
    docker_tag = args.d_org + "/" + args.app_name + ":" + str(app_version)

    # Add org and user (need a separate "describe" call to get authorship) Example:
    # app_desc["org"]: {'handle': 'bestgenetics', 'name': 'Best Genetics, Inc.'}
    # app_desc["user"]: {'dxuser': 'jdoe', 'full_name': 'John Doe'}
    app_desc = describe_app(args.pfda_token, app)
    app["org"] = app_desc.get("org")
    app["user"] = app_desc.get("user")

    # make the CWL
    cwl = pfda_app_to_cwl(app, docker_tag)
    with open("/tmp/Dockstore.cwl", 'w') as outfile:
        print(yaml.dump(cwl), file=outfile)
    # make the Dockerfile
    dockerfile = pfda_export_app_dockerfile(args.pfda_token, app["uid"])
    dockerfile = dockerfile + "\nVOLUME /data\nVOLUME /work" # https://github.com/common-workflow-language/cwltool/issues/30
    # TODO: need to build automatically on Quay.io, wait for it to finish, then register on Dockstore
    if not docker_build(docker_tag, dockerfile):
        sys.exit(1)

    # this is where I upload to Github
    setup_github_repo_and_tags(args.gh_token, args.gh_org, args.app_name, app_version, yaml.dump(cwl), dockerfile)

    # TODO: replace this with the code from Ola and Geet that pushes to Quay.io
    #print("Pushing {} to quay.io".format(docker_tag))
    #docker_push(docker_tag, "ignored_for_now", args.d_org, args.q_account, args.q_token)
    docker_push(docker_tag, "ignored_for_now", args.d_org, "ignore_for_now", "ignore_for_now")

    # TODO: this needs to still be done, see the google doc for endpoint swagger link
    #register_on_dockstore(args.app_name, args.ds_org, args.ds_token)


def register_on_dockstore(repo_name, org, token):
    dockstore_headers={
        'Authorization': 'Bearer {}'.format(token),
        'Accept': 'application/json, text/plain, */*',
        'Content-Type': 'application/json'
    }

    dockstore_data= {
        "mode":"MANUAL_IMAGE_PATH",
        "name":repo_name,
        "toolname":repo_name,
        "namespace":org,
        "registry":"QUAY_IO",
        "gitUrl":"https://github.com/{}/{}".format(org, repo_name),
        "default_dockerfile_path":"/Dockerfile",
        "default_cwl_path":"/Dockstore.cwl",
        "default_wdl_path":"/Dockstore.wdl",
        "default_cwl_test_parameter_file":"/test.cwl.json",
        "default_wdl_test_parameter_file":"/test.wdl.json",
        "is_published":False
    }

    response = requests.post("https://dockstore.org:8443/containers/registerManual",
                             data=json.dumps(dockstore_data),
                             headers=dockstore_headers,
                             allow_redirects=True)

# sets up Git repo, adds files, tags
def setup_github_repo_and_tags(token, org, tool, app_version, cwl_file, dockerfile):
    g = Github(token)
    ag = GitHub(token=token)

    user = g.get_user()
    organization = g.get_organization(org)

    # create repo
    try:
        print ("Creating repo: "+tool+" in org: "+org)
        repo = organization.create_repo(name=tool, description="Pfda2Dockstore Github repo for tool "+tool,
                                homepage="https://github.com", private=False,
                                has_issues=False, has_wiki=False, has_downloads=False )
        # create files in repo
        file_hash = {"dockstore.cwl": cwl_file, "Dockerfile": dockerfile}
        for key in file_hash:
            data = file_hash[key]
            file_path = '/'+ key
            print (" + creating file:" + file_path)
            repo.create_file(file_path, "initial commit", str(data))
        # some cruft here because the first github library I used did the following, can't use this library because of the bug below
        #since = datetime.now() - timedelta(days=1)
        #commits = repo.get_commits(since=since)
        #last = commits[0]
        #print (last.sha)
        # doesn't work according to this bug report!  https://github.com/PyGithub/PyGithub/issues/488
        #repo.create_git_tag(tag, 'the tag message', last.sha, 'commit')
        # try a different way for now
        data = {
          "tag_name": str(app_version),
          "target_commitish": "master",
          "name": str(app_version),
          "body": "the "+str(app_version)+" release",
          "draft": False,
          "prerelease": False
        }
        #print (str(data))
        url = "https://api.github.com/repos/"+org+"/"+tool+"/releases"
        #print("the URL: "+url)
        #headers = {'Authorization': 'token '+args.token}
        ag.repos[org][tool].releases.post(body=data)

    except:
        e = sys.exc_info()[0]
        print("errors creating repo, check to ensure this is not a duplicate: "+str(e))
        sys.exit(1)

# app name -> [app json]
def resolve_pfda_app_name(token, app_name):
    list_of_apps = pfda_api(token, "/list_apps")
    return [app for app in list_of_apps if app["name"] == app_name]

def describe_app(token, app_json):
    app_desc = pfda_api(token, "/describe", {"uid": app_json["uid"], "describe": {"include": {"user": True, "org": True}}})
    return app_desc

def pfda_export_app_dockerfile(token, app_uid):
    return pfda_api(token, "/export_app", {"id": app_uid})["content"]

# call precisionFDA API, return JSON response body
def pfda_api(token, path, body={}):
    url = "https://precision.fda.gov/api" + path
    headers = {
        "Authorization": "Key " + token,
        "Content-Type": "application/json"
    }
    response = requests.post(url, headers=headers, data=json.dumps(body))
    if response.status_code != 200:
        print("precisionFDA API error status {}:".format(response.status_code), file=sys.stderr)
        print(response.json(), file=sys.stderr)
        sys.exit(1)
    return response.json()

# generate CWL tool hash (for YAMLificiation) given the pFDA app spec and what to 'docker pull'
def pfda_app_to_cwl(app, docker_pull):
    cwl = {
        "class": "CommandLineTool",
        "id": app["name"],
        "label": app["title"],
        "cwlVersion": "v1.0",
        "baseCommand": [],
        "requirements": [{
            "class": "DockerRequirement",
            "dockerPull": docker_pull,
            "dockerOutputDirectory": "/data/out"
        }]
    }

    app_spec = app["spec"]

    position = 1
    inputs = {}
    for inp in app_spec["input_spec"]:
        cwl_inp = {
            "doc": inp["help"],
            "inputBinding": {
                "position": position,
                "prefix": "--" + inp["name"]
            }
        }
        if inp["class"] == "string":
            cwl_inp["type"] = "string"
        elif inp["class"] == "int":
            cwl_inp["type"] = "long"
        elif inp["class"] == "file":
            cwl_inp["type"] = "File"
        elif inp["class"] == "boolean":
            cwl_inp["type"] = "boolean"
        elif inp["class"] == "float":
            cwl_inp["type"] = "double"
        else:
            raise Exception("Unsupported input type: {} {}".format(inp["class"], inp["name"]))
        if "default" in inp and inp["class"] != "file":
            cwl_inp["default"] = inp["default"]
        if inp["optional"] is True:
            cwl_inp["type"] = cwl_inp["type"] + "?"
        inputs[inp["name"]] = cwl_inp
        position = position + 1
    cwl["inputs"] = inputs

    outputs = {}
    for outp in app_spec["output_spec"]:
        cwl_outp = {
            "doc": outp["help"]
        }
        if outp["class"] == "file":
            cwl_outp["type"] = "File"
            cwl_outp["outputBinding"] = {
                "glob": "{}/*".format(outp["name"])
            }
        else:
            raise Exception("Unsupported output type: {} {}".format(outp["class"], outp["name"]))
        outputs[outp["name"]] = cwl_outp
    cwl["outputs"] = outputs

    return cwl

def docker_build(tag, dockerfile):
    p = subprocess.Popen(["docker", "build", "-t", tag, "-"], stdin=subprocess.PIPE)
    p.communicate(dockerfile.encode('utf-8'))
    return p.returncode == 0

def docker_push(tag, hub, orgname, accountname, token):
    '''
    Push a tagged image to a specified hub.
    :param tag: Image tag
    :type tag: string
    :param hub: Name of a docker image hub (repository), e.g. "quay.io"
    :type hub: string
    :param orgname: orgname
    :type orgname: string
    :param accountname: accountname (for a quay.io robot account the username is orgname+accountname)
    :type accountname: string
    :param token: token
    :type token: string
    '''
    username_str = "-u={}".format(orgname)
    if accountname:
        username_str += "+" + accountname
    token_str= "-p={}".format(token)
    try:
        # cmd = ["docker", "login", '-u="{}+{}"'.format(orgname, accountname), '-p="{}"'.format(token), "quay.io"]
        #cmd = ["docker", "login", '-u="{}"'.format(accountname), '-p="{}"'.format(token)]
        #subprocess.check_call(cmd, shell=True)
        # TODO: fix me, this ignores "hub" since we're using DockerHub...
        cmd = ["docker", "push", tag]
        subprocess.check_call(cmd)
        subprocess.check_call(["docker", "logout"])
    except subprocess.CalledProcessError as e:
        raise Exception("Failed to push image {} to {}/{}.\n{}".format(tag, hub, orgname, e))

if __name__=="__main__":
    main()
